<!DOCTYPE html>
<html lang="en">

    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>3D Stream Projection on Dome</title>
        <style>
            body {
                margin: 0;
            }

            canvas {
                display: block;
            }

            #image_sub {
                display: none;
            }
        </style>
    </head>

    <body>
        <img id="image_sub" />
        <script src="../lib/three.min.js"></script>
        <script src="../lib/OrbitControls.js"></script>
        <script src="../lib/eventemitter2.js"></script>
        <script src="../lib/roslib.min.js"></script>
        <script type="text/javascript">
            // ROS Bridge Connection ----------------------
            var ros = new ROSLIB.Ros({ url: 'ws://localhost:8081', });
            ros.on('connection', function () { console.log('Connected to websocket server.'); });
            ros.on('error', function (error) { console.log('Error connecting to websocket server: ', error); });
            ros.on('close', function () { console.log('Connection to websocket server closed.'); });
            var listener = new ROSLIB.Topic({
                ros: ros,
                name: '/sky360/frames/annotated/compressed',
                messageType: 'sensor_msgs/msg/CompressedImage',
            });
            listener.subscribe(function (message) { document.getElementById('image_sub').src = 'data:image/jpeg;base64,' + message.data; });

            // Get the image to project to the Dome from a hidden image element with a src being updated by the roslib.js data feed
            const imageElement = document.getElementById('image_sub');
            const imageTexture = new THREE.Texture(imageElement);
            imageTexture.minFilter = THREE.LinearFilter;
            imageTexture.magFilter = THREE.LinearFilter;
            imageTexture.format = THREE.RGBFormat;
            imageTexture.needsUpdate = true;

            // Set up the scene, camera, and renderer
            const scene = new THREE.Scene();
            // const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = .1;
            const renderer = new THREE.WebGLRenderer();
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);
            const dome = createParabolicDome(scene);

            // Add axes
            // const axesHelper = new THREE.AxesHelper(5);
            // scene.add(axesHelper);
            // axesHelper.visible = true;

            // Set up event listener for the dome height slider
            const domeHeightValue = 13;
            document.addEventListener('load', function () {
                const domeHeight = parseFloat(this.value);
                console.log(domeHeight);
                dome.scale.y = domeHeight / 10;
                updateDomeHeight(dome, domeHeight);
            });

            // Update the dome height
            function updateDomeHeight(dome, height) {
                const scale = height / domeHeight; // Calculate the scale factor
                dome.scale.y = scale; // Apply the scale factor to the dome's y-axis
            }

            function createParabolicDome(scene) {
                const domeRadius = 5;
                const domeHeight = 2;
                const domeSegments = 64;
                function domeFunction(u, v, target) {
                    const x = u * domeRadius * 2 - domeRadius;
                    const z = v * domeRadius * 2 - domeRadius;
                    const y = -((x * x + z * z) / (4 * domeHeight)) + domeHeight;
                    target.set(x, y, z);
                }
                const domeGeometry = new THREE.ParametricGeometry(domeFunction, domeSegments, domeSegments);
                // const video = document.getElementById('video');
                // const videoTexture = new THREE.VideoTexture(video);
                // const textureLoader = new THREE.TextureLoader();
                // const imageTexture = textureLoader.load('../images/sunny2.png');
                const domeMaterial = new THREE.MeshBasicMaterial({ map: imageTexture, side: THREE.FrontSide });
                // const domeMaterial = new THREE.MeshBasicMaterial({ map: videoTexture, side: THREE.FrontSide });
                const dome = new THREE.Mesh(domeGeometry, domeMaterial);
                scene.add(dome);
                return dome;
            }

            // Add OrbitControls
            const controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.02;
            controls.screenSpacePanning = true;
            controls.enablePan = true;
            controls.panAxis = new THREE.Vector3(1, 1, 0); // Restrict panning to the x and y axes
            controls.minDistance = 0.01;
            controls.maxDistance = 15; // Set the maximum zoom out distance

            // Update the image projected to the dome
            function updateTexture() {
                imageTexture.needsUpdate = true;
            }

            imageElement.addEventListener('load', updateTexture);

            // Render the scene
            function animate() {
                requestAnimationFrame(animate);
                updateTexture();
                controls.update();
                renderer.render(scene, camera);
            }

            animate();

            // Resize the renderer when the window is resized
            window.addEventListener('resize', function () {
                const width = window.innerWidth;
                const height = window.innerHeight;
                renderer.setSize(width, height);
                camera.aspect = width / height;
                camera.updateProjectionMatrix();
            });
        </script>
    </body>
</html>
