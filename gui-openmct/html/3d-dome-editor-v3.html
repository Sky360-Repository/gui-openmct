<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>3D Parabolic Dome Editor</title>
    <style>
      body {
        margin: 0;
        display: flex;
      }
      canvas {
        display: block;
      }
      #video {
        display: none;
      }
      #controls {
        padding: 20px;
        background-color: rgba(255, 255, 255, 0.8);
      }
      #container {
        min-width: 300px;
    }
      .control-row {
        display: flex;
        justify-content: space-between;
        align-items: center;
      }
    </style>
  </head>
  <body>
    <video id="video" playsinline autoplay muted loop>
      <source src="../images/birds_and_plane.mp4" type="video/mp4" />
    </video>

<div id="container">
    <div id="controls">
      <div class="control-row">
        <label for="toggleAxes">Display Axes:</label>
        <input checked type="checkbox" id="toggleAxes" />
      </div>
      <div class="control-row">
        <label for="toggleCircle">Display Ground Circle:</label>
        <input type="checkbox" id="toggleCircle" />
      </div>
      <!-- <div class="control-row">
        <label for="toggleProjectionCenter">Display Center of Projection:</label>
        <input checked type="checkbox" id="toggleProjectionCenter" />
      </div>
      <div class="control-row">
        <label for="toggleDomeCenter">Display Center of Dome:</label>
        <input checked type="checkbox" id="toggleDomeCenter" />
      </div> -->
      <div class="control-row">
        <label for="toggleDome">Display Dome:</label>
        <input checked type="checkbox" id="toggleDomeDisplay" />
      </div>
      <div class="control-row">
        <label for="domeHeightSlider">Dome Height:</label>
        <input type="range" id="domeHeightSlider" min="10" max="20" step=".1" value="16" />
        <span id="domeHeightValue"></span>
      </div>
      <!-- <div class="control-row">
        <label for="domeWidthSegmentsSlider">Dome Width Segments:</label>
        <input type="range" id="domeWidthSegmentsSlider" min="5" max="50" step="5" value="30" />
        <span id="domeWidthSegmentsValue"></span>
      </div>
      <div class="control-row">
        <label for="domeHeightSegmentsSlider">Dome Height Segments:</label>
        <input type="range" id="domeHeightSegmentsSlider" min="5" max="30" step="5" value="15" />
        <span id="domeHeightSegmentsValue"></span>
      </div> -->
      <div class="control-row">
        <label for="domeHeightOffset">Dome Height Offset:</label>
        <input type="number" id="domeHeightOffset" value="0" style="width: 50px"/>
      </div>
      <div class="control-row">
        <label for="domeRotateDegrees">Dome Rotation (Degrees):</label>
        <input type="number" id="domeRotateDegrees" value="0" style="width: 50px" />
      </div>


      <div class="control-row">
        <label for="domeTiltXSlider">Dome Tilt X:</label>
        <input type="range" id="domeTiltXSlider" min="-13" max="13" step=".01" value="0" />
        <span id="domeTiltXValue"></span>
      </div>

      <div class="control-row">
        <label for="domeTiltYSlider">Dome Tilt Y:</label>
        <input type="range" id="domeTiltYSlider" min="-13" max="13" step=".01" value="0" />
        <span id="domeTiltYValue"></span>
      </div>

      <!-- <div class="control-row">
        <label for="domeTiltX">Dome Tilt X:</label>
        <input type="number" id="domeTiltX" value="0"  style="width: 50px"/>
      </div>
      <div class="control-row">
        <label for="domeTiltY">Dome Tilt Y:</label>
        <input type="number" id="domeTiltY" value="0"  style="width: 50px"/>
      </div> -->
      <div class="control-row">
        <label for="projLongitudeOffset">Projection Longitude Offset:</label>
        <input type="number" id="projLongitudeOffset" value="0" style="width: 50px" />
      </div>
      <div class="control-row">
        <label for="projLatitudeOffset">Projection Latitude Offset:</label>
        <input type="number" id="projLatitudeOffset" value="0"  style="width: 50px"/>
      </div>
      <div class="control-row">
        <label for="projRotation">Projection Rotation (Degrees):</label>
        <input type="number" id="projRotation" value="0"  style="width: 50px"/>
      </div>
        <br>
      <!-- <button id="viewInsideDomeButton">Inner Dome</button> -->
</div>

    </div>
    <script src="../lib/three.min.js"></script>
    <script src="../lib/OrbitControls.js"></script>
    <script src="../lib/eventemitter2.js"></script>
    <script src="../lib/roslib.min.js"></script>
    <script>

      // Set up the scene, camera, and renderer
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 0.1, 10000);
        const cameraPosition = new THREE.Vector3(13, 1, .1);
        const lookatPosition = new THREE.Vector3(20, 20, 20);
        // Set the camera position
        camera.position.copy(cameraPosition);
        // Make the camera look at the lookatPosition
        camera.lookAt(lookatPosition);
        // camera.position.y = 13;
        // camera.position.z = 10;

        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Set up the dome
        const domeRadius = 10;
        const domeWidthSegments = 15;
        const domeHeightSegments = 15;
        const domeHeight = 5;
        const dome = createParabolicDome(scene);
        updateDomeHeight(dome, 16);

        // updateDomeHeightOffset(dome, 16);

        // Set up the ground
        const circle = createGroundWithRotationalIndex(scene);
        circle.visible = false;
        // Set up the projected Image to the dome
        // const projectionCenterPoint = createPoint(scene, dome.domeCenter);
        // const domeCenterPoint = createPoint(scene, dome.domeCenter);

        // Get references to the width and height segments sliders and their value spans
        // const domeWidthSegmentsSlider = document.getElementById('domeWidthSegmentsSlider');
        // const domeWidthSegmentsValue = document.getElementById('domeWidthSegmentsValue');
        // const domeHeightSegmentsSlider = document.getElementById('domeHeightSegmentsSlider');
        // const domeHeightSegmentsValue = document.getElementById('domeHeightSegmentsValue');
        // Set up event listeners for the width and height segments sliders
        // domeWidthSegmentsSlider.addEventListener('input', function () {
        //     const widthSegments = parseInt(this.value);
        //     updateDomeWidthSegments(dome, widthSegments);
        //     domeWidthSegmentsValue.textContent = widthSegments;
        // });
        // domeHeightSegmentsSlider.addEventListener('input', function () {
        //     const heightSegments = parseInt(this.value);
        //     updateDomeHeightSegments(dome, heightSegments);
        //     domeHeightSegmentsValue.textContent = heightSegments;
        // });
        // Update the dome's width segments
        // function updateDomeWidthSegments(dome, segments) {
        //     const geometry = dome.geometry;
        //     const newGeometry = new THREE.ParametricGeometry(
        //         geometry.parameters.func,
        //         segments,
        //         geometry.parameters.heightSegments
        //     );
        //     dome.geometry.dispose();
        //     dome.geometry = newGeometry;
        // }
        // // Update the dome's height segments
        // function updateDomeHeightSegments(dome, segments) {
        //     const geometry = dome.geometry;
        //     const newGeometry = new THREE.ParametricGeometry(
        //         geometry.parameters.func,
        //         geometry.parameters.widthSegments,
        //         segments
        //     );
        //     dome.geometry.dispose();
        //     dome.geometry = newGeometry;
        // }
        // Get references to the dome height slider and its value span
        const domeHeightSlider = document.getElementById('domeHeightSlider');
        const domeHeightValue = document.getElementById('domeHeightValue');
        // Set up event listener for the dome height slider
        domeHeightSlider.addEventListener('input', function () {
            const domeHeight = parseFloat(this.value);
            updateDomeHeight(dome, domeHeight);
            domeHeightValue.textContent = domeHeight;
        });
        // Update the dome height
        function updateDomeHeight(dome, height) {
            const scale = height / domeHeight; // Calculate the scale factor
            dome.scale.y = scale; // Apply the scale factor to the dome's y-axis
        }
		// Add axes
		const axesHelper = new THREE.AxesHelper(5);
		scene.add(axesHelper);
		axesHelper.visible = true;
		// Set up the user interface
		const toggleAxesCheckbox = document.getElementById('toggleAxes');
		toggleAxesCheckbox.addEventListener('change', function () {
		    axesHelper.visible = this.checked;
		});
        // Set up the dome height
		const domeHeightOffsetInput = document.getElementById('domeHeightOffset');
		domeHeightOffsetInput.addEventListener('input', function () {
		    updateDomeHeightOffset(dome, parseFloat(this.value));
		});
        // Set up the dome rotation
		const domeRotateDegreesInput = document.getElementById('domeRotateDegrees');
		domeRotateDegreesInput.addEventListener('input', function () {
		    // updateDomeRotation(dome, parseFloat(this.value));
            const rotationDegrees = parseFloat(this.value);
            dome.rotation.y = THREE.MathUtils.degToRad(rotationDegrees);
		});

        const domeTiltXSlider = document.getElementById('domeTiltXSlider');
        const domeTiltXValue= document.getElementById('domeTiltXValue');
        // Set up the dome tilt X
        domeTiltXSlider.addEventListener('input', function () {
            const rotationDegrees = parseFloat(this.value);
            dome.rotation.x = THREE.MathUtils.degToRad(rotationDegrees);
            domeTiltXValue.textContent = rotationDegrees;
		});

        const domeTiltYSlider = document.getElementById('domeTiltYSlider');
        const domeTiltYValue= document.getElementById('domeTiltYValue');
        // Set up the dome tilt Y
        domeTiltYSlider.addEventListener('input', function () {
            const rotationDegrees = parseFloat(this.value);
            dome.rotation.z = THREE.MathUtils.degToRad(rotationDegrees);
            domeTiltYValue.textContent = rotationDegrees;
		});

        // Set up the circle
		const toggleCircleCheckbox = document.getElementById('toggleCircle');
		toggleCircleCheckbox.addEventListener('change', function () {
		circle.visible = this.checked;
		});
        // Set up the circle
		const toggleDomeDisplay = document.getElementById('toggleDomeDisplay');
		toggleDomeDisplay.addEventListener('change', function () {
		dome.visible = this.checked;
		});
        // Set up the Center of Projection
		// const toggleProjectionCenterCheckbox = document.getElementById('toggleProjectionCenter');
        //     toggleProjectionCenterCheckbox.addEventListener('change', function () {
        //     projectionCenterPoint.visible = this.checked;
		// });
		// const toggleDomeCenterCheckbox = document.getElementById('toggleDomeCenter');
        //     toggleDomeCenterCheckbox.addEventListener('change', function () {
        //     domeCenterPoint.visible = this.checked;
		// });
		const projLongitudeOffsetInput = document.getElementById('projLongitudeOffset');
		projLongitudeOffsetInput.addEventListener('input', function () {
		updateProjectionOffsets(dome, parseFloat(this.value), parseFloat(projLatitudeOffsetInput.value));
		});
		const projLatitudeOffsetInput = document.getElementById('projLatitudeOffset');
		projLatitudeOffsetInput.addEventListener('input', function () {
		updateProjectionOffsets(dome, parseFloat(projLongitudeOffsetInput.value), parseFloat(this.value));
		});
		const projRotationInput = document.getElementById('projRotation');
		projRotationInput.addEventListener('input', function () {
		updateProjectionRotation(dome, parseFloat(this.value));
		});
		// Add OrbitControls
		const controls = new THREE.OrbitControls(camera, renderer.domElement);
		controls.enablePan = true;
        controls.enableDamping = true;
		controls.screenSpacePanning = true;
        controls.panAxis = new THREE.Vector3(1, 1, 0); // Restrict panning to the x and y axes
        controls.minDistance = 0.01;
        controls.maxDistance = 15; // Set the maximum zoom out distance
		// Render the scene
		function animate() {
			requestAnimationFrame(animate);
			controls.update();
			renderer.render(scene, camera);
		}
		animate();
		// Resize the renderer when the window is resized
		window.addEventListener('resize', function () {
			const width = window.innerWidth;
			const height = window.innerHeight;
			renderer.setSize(width, height);
			camera.aspect = width / height;
			camera.updateProjectionMatrix();
		});
        // Update the dome height offset
        function updateDomeHeightOffset(dome, offset) {
            dome.position.y = offset;
        }
		// Helper Functions
		function createTickMarks(circleRadius, ticksCount, height) {
			const tickMarks = new THREE.Group();
			for (let i = 0; i < ticksCount; i++) {
			const angle = (i * 360) / ticksCount;
			const tickGeometry = new THREE.CylinderGeometry(0.05, 0.05, height, 8);
			const tickMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
			const tick = new THREE.Mesh(tickGeometry, tickMaterial);
			const radians = THREE.MathUtils.degToRad(angle);
			tick.position.set(circleRadius * Math.cos(radians), circleRadius * Math.sin(radians), 0);
			tick.lookAt(new THREE.Vector3(0, 0, 0));
			tickMarks.add(tick);
			}
            console.log(tickMarks);
			return tickMarks;
		}
		function updateProjectionOffsets(dome, longitudeOffset, latitudeOffset) {
			const texture = dome.material.map;
			const offset = {
			x: THREE.MathUtils.degToRad(longitudeOffset) / (2 * Math.PI),
			y: THREE.MathUtils.degToRad(latitudeOffset) / (2 * Math.PI),
			};
			texture.offset.set(offset.x, offset.y);
		}
		function updateProjectionRotation(dome, rotation) {
			const texture = dome.material.map;
			texture.rotation = THREE.MathUtils.degToRad(rotation);
        }
        // Create Dome Center Point
		function createPoint(scene, position) {
			const geometry = new THREE.SphereGeometry(0.1, 1, 1);
			const material = new THREE.MeshBasicMaterial({ color: 0xffff00 });
			const point = new THREE.Mesh(geometry, material);
			point.position.copy(position);
			scene.add(point);
			return point;
		}
		function createGroundWithRotationalIndex(scene) {
			const radius = 5;
			const segments = 72; // 360/5 = 72 segments for 5-degree ticks
			const circleGeometry = new THREE.CircleGeometry(radius, segments);
			const tickGeometry = new THREE.BoxGeometry(0.05, 0.1, 0.05);
            // Grey not MeshbasicMaterial visible on both sides that can take an opacity
            const material = new THREE.MeshBasicMaterial({
                color: 0xffffff,
                side: THREE.DoubleSide, // Enables two-sided rendering
                opacity: 0.3,
                transparent: true
            });
			const circle = new THREE.Mesh(circleGeometry, material);
			circle.rotation.x = -Math.PI / 2;
			for (let i = 0; i < segments; i++) {
			const tick = new THREE.Mesh(tickGeometry, material);
			const angle = (2 * Math.PI * i) / segments;
			tick.position.set(radius * Math.cos(angle), radius * Math.sin(angle), 0);
			tick.rotation.x = Math.PI / 2;
			circle.add(tick);
			}
			scene.add(circle);
			return circle;
		}
        function createParabolicDome(scene) {
            const domeRadius = 5;
            const domeHeight = 5;  // adjust this value to change the dome shape
            function domeFunction(u, v, target) {
                const x = u * domeRadius * 2 - domeRadius;
                const z = v * domeRadius * 2 - domeRadius;
                const y = -((x * x + z * z) / (4 * domeHeight));
                target.set(x, y+1.3, z);
            }
            // Create Texture from an Image
            var image = '../images/sunny2.png'
            const textureLoader = new THREE.TextureLoader();
            const domeImageTexture = textureLoader.load(image);
            // Create Texture from a Video
            var domeVideoTexture = new THREE.VideoTexture(video);
            const domeWidthSegments = 50;
            const domeHeightSegments = 50;
            const geometry = new THREE.ParametricGeometry(domeFunction, domeWidthSegments, domeHeightSegments);
            // Apply the Video or Image Texture
            const domeMaterial = new THREE.MeshBasicMaterial({ map: domeImageTexture, side: THREE.FrontSide });
            const dome = new THREE.Mesh(geometry, domeMaterial);
            dome.domeCenter = new THREE.Vector3(0, domeRadius + domeHeight, 0); // Adjust the domeCenter position
            scene.add(dome);
            return dome;
        }

        // Sphere Dome
        function createSphericalDome(scene) {
            const radius = 5;
            const widthSegments = 30;
            const heightSegments = 30;
            const phiStart = 0;
            const phiLength = Math.PI * 2;
            const thetaStart = 0;
            const thetaLength = Math.PI / 2;
            const geometry = new THREE.SphereGeometry(
            radius,
            widthSegments,
            heightSegments,
            phiStart,
            phiLength,
            thetaStart,
            thetaLength
            );
            // Create Texture from an Image
            var image = '../images/sunny2.png'
            const textureLoader = new THREE.TextureLoader();
            const domeImageTexture = textureLoader.load(image);

            // Create Texture from a Video
            var domeVideoTexture = new THREE.VideoTexture(video);
            // Apply the Video or Image Texture
            const domeMaterial = new THREE.MeshBasicMaterial({ map: domeImageTexture, side: THREE.FrontSide });
            // const material = new THREE.MeshBasicMaterial({
            //     color: 0x00ff00,
            //     wireframe: true,
            //     transparent: true,
            //     opacity: 0.5,
            // });
            const dome = new THREE.Mesh(geometry, domeMaterial);
            dome.position.y = radius;
            dome.domeCenter = new THREE.Vector3(0, radius, 0);
            scene.add(dome);
            return dome;
        }

        function rotateDome(x, y, z) {
            dome.rotation.x += x;
            dome.rotation.y += y;
            dome.rotation.z += z;
        }

        function moveDome(x, y, z) {
            dome.position.x += x;
            dome.position.y += y;
            dome.position.z += z;
        }

        // Get a reference to the button element
        // const viewInsideDomeButton = document.getElementById('viewInsideDomeButton');
        // // Add a click event listener to the button
        // viewInsideDomeButton.addEventListener('click', moveCameraInsideDome);
        // Function to move the camera
        // function moveCameraInsideDome() {
        //     // Define the camera position and target position
        //     const cameraPosition = new THREE.Vector3(.1, .1, .1);
        //     const lookatPosition = new THREE.Vector3(20, 20, -20);
        //     // Set the camera position
        //     camera.position.copy(cameraPosition);
        //     // Make the camera look at the lookatPosition
        //     camera.lookAt(lookatPosition);
        // }

        moveDome(0,-.3,0);

</script>
</body>
</html>