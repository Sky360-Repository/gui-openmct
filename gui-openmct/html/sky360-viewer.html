<!DOCTYPE html>
<html>
    <head>
        <style>
            body {
                font-family: sans-serif;
                font-size: 16px;
                color: #aaa;
                text-shadow: none;
            }
            #maskCanvas {
                border: 1px solid black;
            }
        </style>
        <title>Stream with Classification</title>
        <meta charset="utf-8" />
        <script src="../lib/eventemitter2.js"></script>
        <script src="../lib/roslib.min.js"></script>
    </head>
    <body>
        <div style="display: flex; flex-direction: column; width: 25%; position: relative; float: right"">
            <div style=" display: flex; justify-content: space-between; padding-bottom: 5px;"><label for="buffer_enabled">Enable Buffer:</label><input type="checkbox" id="buffer_enabled" name="buffer_enabled" checked></div>
            <div style="display: flex; justify-content: space-between; padding-bottom: 5px;"><label for="buffer_size">Buffer Size:</label><input type="number" id="buffer_size" name="buffer_size" value="40" style="width: 50px;">
            </div>
            <div style="display: flex; justify-content: space-between; padding-bottom: 5px;"><label for="buffer_balance">Buffered Frames:</label><span id="buffer_balance">0</span></div>
            <div style="display: flex; justify-content: space-between; padding-bottom: 5px;"><label for="frame_rate">Target Frame Rate (FPS):</label><input type="number" id="frame_rate" name="frame_rate" value="6"
                    style="width: 50px;"></div>
            <div style="display: flex; justify-content: space-between; padding-bottom: 5px;"><label hidden for="actual_frame_rate">FPS (Last Frames):</label><span hidden id="actual_frame_rate">0</span></div>
            <div style="display: flex; justify-content: space-between; padding-bottom: 5px;"><label for="total_avg_frame_rate">FPS (Total Avg):</label><span id="total_avg_frame_rate">0</span></div>
            <div style="display: flex; justify-content: space-between; padding-bottom: 5px;"><label for="recent_avg_frame_rate">FPS (Last 4 Avg)</label><span id="recent_avg_frame_rate">0</span></div>
            <br>
            <div style="display: flex; justify-content: space-between; padding-bottom: 5px;"><label for="recent_avg_message_rate">Message Per Second (Last 4 Avg):</label><span id="recent_avg_message_rate">0</span></div>
            <div style="display: flex; justify-content: space-between; padding-bottom: 5px;"><label for="total_avg_message_rate">Message Per Second (Total Avg):</label><span id="total_avg_message_rate">0</span></div>
            <div style="display: flex; justify-content: space-between; padding-bottom: 5px;"><label hidden for="message_rate">Message Per Second (Last Messages):</label><span hidden id="message_rate">0</span></div>
            <br>
            <div style="position: relative; float: right; padding-bottom: 5px;"><label for="message_rate"><button id="editMaskBtn">Edit Image Mask</button></label></div>
            <div style="position
            <div style="position: relative; float: right; padding-bottom: 5px;"><label for="message_rate"><button id="clearMaskBtn">Clear Image Mask</button></label></div>
            <div style="position: relative; float: right; padding-bottom: 5px;"><label for="message_rate"><button id="invertMaskBtn">Invert Image Mask</button></label></div>
            <div style="position: relative; float: right; padding-bottom: 5px;"><label for="message_rate"><button id="saveMaskJPG">Save Mask as JPG</button></label></div>
            <div style="position: relative; float: right; padding-bottom: 5px;"><label for="message_rate"><button id="saveMaskSVG">Save Mask as SVG</button></label></div>
            <div style="position: relative; float: right; padding-bottom: 5px;"><label for="message_rate"><button id="sendMaskJPG">Send Mask</button></label></div>
        </div>
        <div id="stream" style="position: relative; width: 70%; float: left">
            <img width="860" height="860" id="image_sub" />
            <canvas width="860" height="860" id="maskCanvas" style="position:absolute;top:0;left:0;z-index:10;"></canvas>
        </div>
    <script>
        function init() { window.addEventListener('DOMContentLoaded', function () {
                var ros = new ROSLIB.Ros({
                    url: 'ws://localhost:8081'
                });
                ros.on('connection', function () {
                    console.log('Connected to websocket server.');
                });
                ros.on('error', function (error) {
                    console.log('Error connecting to websocket server: ', error);
                });
                ros.on('close', function () {
                    console.log('Connection to websocket server closed.');
                });
                var imageBuffer = [];
                var classificationBuffer = [];  // New buffer for classification
                var frameRate = 6;
                var lastMessageTime = null;
                var messageRate = 0;
                var bufferSize = document.getElementById('buffer_size').value;
                document.getElementById('buffer_size').addEventListener('input', function() {
                    bufferSize = parseInt(this.value, 10);
                });
                var lastFrameTime = null;
                var actualFrameRate = 0;
                const maskCanvas = document.getElementById('maskCanvas');
                const ctx = maskCanvas.getContext('2d');
                var listener = new ROSLIB.Topic({
                    ros: ros,
                    name: '/sky360/frames/annotated/compressed',
                    messageType: 'sensor_msgs/msg/CompressedImage'
                });
                listener.subscribe(function (message) {
    updateMessageRate();
    if (document.getElementById('buffer_enabled').checked) {
        if (imageBuffer.length < bufferSize) {
            imageBuffer.push({data: message, timestamp: new Date()});
        }
    } else {
        document.getElementById('image_sub').src = "data:image/jpeg;base64," + message.data;
    }
});

                var sky360_single_frame_classifier = new ROSLIB.Topic({
                    ros: ros,
                    name: 'sky360/classification',
                    messageType: 'std_msgs/String'
                });
                sky360_single_frame_classifier.subscribe(function (message) {
                    console.log('test');
                    updateMessageRate();
                    // Add an object with data and timestamp instead of just the message data
                    classificationBuffer.push({data: message, timestamp: new Date()});
                    parseClassificationMsg(message);
                });
                function parseClassificationMsg(message) {
                    var messageCopy = JSON.parse(message.data);
                    const labels = ['Bird', 'Cloud', 'Unknown', 'Edge', 'Empty', 'Rain drop', 'Plane', 'Lens flare'];
                    messageCopy.objects.forEach(obj => {
                        let classificationArray = obj.classification[0];
                        let maxIndex = classificationArray.indexOf(Math.max(...classificationArray));
                        let classificationLabel = labels[maxIndex];
                        let confidenceScore = (classificationArray[maxIndex] * 100).toFixed(2);
                        // Add the classificationLabel and confidenceScore to the object
                        obj.classificationLabel = classificationLabel;
                        obj.confidenceScore = confidenceScore;
                    });
                    console.log(JSON.stringify(messageCopy, null, 2));
                }
                function processImage() {
                    if (imageBuffer.length > 0 && classificationBuffer.length > 0) {
                        // Check the timestamps to decide whether to process the data
                        let imgTimestamp = imageBuffer[0].timestamp;
                        let classificationTimestamp = classificationBuffer[0].timestamp;
                        if (imgTimestamp.getTime() === classificationTimestamp.getTime()) {
                            // Same timestamps - draw the image and classification
                            var imgMessage = imageBuffer.shift().data;
                            var classificationMessage = classificationBuffer.shift().data;
                            document.getElementById('image_sub').src = "data:image/jpeg;base64," + imgMessage.data;
                            drawClassificationOnCanvas(classificationMessage);
                        } else if (imgTimestamp.getTime() < classificationTimestamp.getTime()) {
                            // Image is older - discard it
                            imageBuffer.shift();
                        } else {
                            // Classification is older - discard it
                            classificationBuffer.shift();
                        }
                    }
                    document.getElementById('buffer_balance').innerText = imageBuffer.length;
                    setTimeout(processImage, 1000 / frameRate);
                }
                function processClassification() {
                    if (classificationBuffer.length > 0 && document.getElementById('buffer_enabled').checked) {
                        let classificationMessage = classificationBuffer.shift();
                        // Find the matching image message based on timestamp
                        let matchingImageIndex = imageBuffer.findIndex(img => img.timestamp.getTime() === classificationMessage.timestamp.getTime());
                        if (matchingImageIndex !== -1) {
                            let imageMessage = imageBuffer[matchingImageIndex];
                            document.getElementById('image_sub').src = "data:image/jpeg;base64," + imageMessage.data.data;
                            drawBoundingBoxes(classificationMessage); // draw the bounding boxes on the image
                        }
                    }
                    // document.getElementById('classification_buffer_balance').innerText = classificationBuffer.length;
                    setTimeout(processClassification, 1000 / frameRate);
                }
                // Call processImage for the first time
                processImage();

                var frameCount = 0;
                var totalFrameRate = 0;
                var recentFrameRates = [];
                var messageCount = 0;
                var totalMessageRate = 0;
                var recentMessageRates = [];

                function updateActualFrameRate() {
                    var currentTime = new Date().getTime();
                    if (lastFrameTime !== null) {
                        var timeDifference = currentTime - lastFrameTime;
                        actualFrameRate = 1000 / timeDifference;
                        document.getElementById('actual_frame_rate').innerText = actualFrameRate.toFixed(2);
                        // Update total average frame rate
                        frameCount++;
                        totalFrameRate += actualFrameRate;
                        document.getElementById('total_avg_frame_rate').innerText = (totalFrameRate / frameCount).toFixed(2);
                        // Update recent average frame rate (last 4 frames)
                        recentFrameRates.push(actualFrameRate);
                        if (recentFrameRates.length > 4) {
                            recentFrameRates.shift();
                        }
                        var recentAvgFrameRate = recentFrameRates.reduce((a, b) => a + b, 0) / recentFrameRates.length;
                        document.getElementById('recent_avg_frame_rate').innerText = recentAvgFrameRate.toFixed(2);
                    }
                    lastFrameTime = currentTime;
                }
                function updateMessageRate() {
                    var currentTime = new Date().getTime();
                    if (lastMessageTime !== null) {
                        var timeDifference = currentTime - lastMessageTime;
                        messageRate = 1000 / timeDifference;
                        document.getElementById('message_rate').innerText = messageRate.toFixed(2);
                        // Update total average message rate
                        messageCount++;
                        totalMessageRate += messageRate;
                        document.getElementById('total_avg_message_rate').innerText = (totalMessageRate / messageCount).toFixed(2);
                        // Update recent average message rate (last 4 messages)
                        recentMessageRates.push(messageRate);
                        if (recentMessageRates.length > 4) {
                            recentMessageRates.shift();
                        }
                        var recentAvgMessageRate = recentMessageRates.reduce((a, b) => a + b, 0) / recentMessageRates.length;
                        document.getElementById('recent_avg_message_rate').innerText = recentAvgMessageRate.toFixed(2);
                    }
                    lastMessageTime = currentTime;
                }
                processClassification();
            });}
            window.onload = init();
            // const videoPlayer = document.getElementById('videoPlayer');
            const videoPlayer = document.getElementById('image_sub');
            const maskCanvas = document.getElementById('maskCanvas');
            const ctx = maskCanvas.getContext('2d');
            const contextMenu = document.getElementById('contextMenu');
            const editMaskBtn = document.getElementById('editMaskBtn');
            const invertMaskBtn = document.getElementById('invertMaskBtn');
            const clearMaskBtn = document.getElementById('clearMaskBtn');
            const saveMaskJPG = document.getElementById('saveMaskJPG');
            const saveMaskSVG = document.getElementById('saveMaskSVG');
            const sendMaskJPG = document.getElementById('sendMaskJPG');
            let drawing = false;
            let editMode = false;
            let polygons = [];
            let offset = 0;
            videoPlayer.addEventListener('loadedmetadata', () => {
                maskCanvas.width = videoPlayer.offsetWidth;
                maskCanvas.height = videoPlayer.offsetHeight;
            });

            function drawBoundingBoxes(classificationMessage) {
                let messageCopy = classificationMessage.data;
                // Clear existing drawings before each frame
                ctx.clearRect(0, 0, maskCanvas.width, maskCanvas.height);
                messageCopy.objects.forEach(obj => {
                    let centerX = (obj.bounding_box[0] + obj.bounding_box[2]) / 2;
                    let centerY = (obj.bounding_box[1] + obj.bounding_box[3]) / 2;
                    // Draw a circle at the center of the bounding box
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, 32, 0, 2 * Math.PI);
                    ctx.fillStyle = "red";
                    ctx.fill();
                    // Draw the classification label next to the circle
                    ctx.font = "20px Arial";
                    ctx.fillText(obj.classificationLabel, centerX + 40, centerY);
                });
            }
            update();
        </script>
    </body>
</html>